import user from "../../routes/user.js";
import { AppDataSource } from "../DataSource.js";
import { MatchModel } from "../models/MatchModel.js";
import { UserService } from "./UserService.js";

export class MatchService {
    protected matchRepo = AppDataSource.getRepository(MatchModel);
    public userService: UserService;

    constructor(userService: UserService) {
        this.userService = userService;
    }

    //get matchModel by match/gameId
    async getMatchById(matchId: number) {
        return await this.matchRepo.findOne({
            where: { matchModelId: matchId },
            relations: ['player1', 'player2', 'winner', 'lobbyParticipants']
        })
    }

    //get MatchModel by lobbyId
    async getMatchLobbyById(lobbyId: string) {
        return await this.matchRepo.findOne({
            where: { lobbyId },
            relations: ['player1', 'player2', 'winner', 'lobbyParticipants']
        })
    }

    //update score of match / do winner update in DB
    async updateScore(matchId: number, player1Score: number, player2Score: number, winnerId?: number) {
        const match = await this.getMatchById(matchId);

        if (!match) {
            throw new Error("match not found");
        }

        match.player1Score = player1Score;
        match.player2Score = player2Score;

        //set winner in DB
        if (winnerId) {
            const winner = await this.userService.findUserById(winnerId)
            if (!winner) {
                throw new Error("Couldn't find winner in users");
            }
            match.winner = winner;
            match.winnerId = winnerId;
            match.status = 'completed'
            match.endedAt = new Date();
        }
        return await this.saveMatch(match);
    }

    //Come one really need an explanation here???
    async saveMatch(match: MatchModel) {
        return await this.matchRepo.save(match);
    }

    //same shit as up there??
    async deleteMatch(matchId: number) {
        const match = await this.getMatchById(matchId);
        if (!match) {
            throw new Error("couldnt do it");
        }
        return await this.matchRepo.remove(match);
    }

    //table join search for finding a matchmodel by using the user/playerId (this should be the same btw!!!)
    async findMatchByPlayerId(playerId: number) {
        return await this.matchRepo.createQueryBuilder("match")
            .leftJoinAndSelect("match.player1", "player1")
            .leftJoinAndSelect("match.player2", "player2")
            .leftJoinAndSelect("match.winner", "winner")
            .where("player1.id = :id", { id: playerId })
            .orWhere("player2.id = :id", { id: playerId })
            .orderBy("match.id", "DESC")
            .getMany();
    }

    //Get UserName from userService using ID
    protected async getUsernameById(userId: number) {
        const user = await this.userService.findUserById(userId);
        return user?.username;
    }

    //check for Winner / Loser of current player in the Match!!
    protected getWinner(match: MatchModel, userId: number) {
        if (!match.winnerId) {
            return "In Progress";
        }
        return match.winnerId === userId ? "Won" : "Lost";
    }

    async createInitialMatchModelforLobby(lobbyId: string, userId: number) {
        const player1 = await this.userService.findUserById(userId)
        if (player1 == null)
            throw Error("?? User doesnt exist in DB")

        const match = new MatchModel();
        //matchModelId is AUTOGENERATED!
        match.lobbyId = lobbyId;
        // match.gameAdminId = userId;
        match.createdAt = new Date();
        match.player1 = player1;
        match.player2 = null;
        match.maxPlayers = 2; //currently hardcoded!!
        match.isLobbyOpen = true;
        match.status = "pending";
        match.hasPassword = false;
        match.invitedUserIds = [];
        match.lobbyParticipants = [];
        match.player1Score = 0
        match.player2Score = 0
        match.readyStatusMap = []

        return await this.saveMatch(match);
    }

    //function that should return score values / playerInfo of specified Match!
    async getMatchStateById(matchId: number, userId: number) {
        const match = await this.getMatchById(matchId);
        if (!match) {
            throw new Error("match doesnt exist");
        }
        return this.getWinner(match, userId);
    }

    // add participant to lobby (usually player 2 for now)
    // according to gameId and userId get matchModel from DB, find user in DB.
    async addLobbyParticipant(matchId: number, userId: number) {
        try {
            const game = await this.getMatchById(matchId);
            const user = await this.userService.findUserById(userId);

            //if game / user doesnt exist in db throw error!
            if (!game || !user) {
                throw new Error("Couldn't find correct game/user");
            }

            // if null lobby in DB set to empty array!
            if (!game.lobbyParticipants) {
                game.lobbyParticipants = [];
            }

            //search for user in lobbyParticipants list of DataBase MatchModel
            //push into DB List if not existing!!
            const existingParticipant = game.lobbyParticipants.find(p => p.id === userId);
            if (!existingParticipant) {
                game.lobbyParticipants.push(user);
            }

            //if lobbyParticipants are equal to 2 and no player2Id and player1Id isnt player2Id
            // set user to player 2! save in DB
            if (game.lobbyParticipants.length === 2 && !game.player2?.id && game.player1?.id !== userId) {
                game.player2 = user;
            }
            return await this.saveMatch(game);
        }
        catch (error) {
            console.error("Couldn't add user to lobby", error);
            throw new Error("Failed to add user");
        }
    }

    async closeLobby(gameId: number) {
        const game = await this.getMatchById(gameId);
        if (!game) {
            throw new Error("fk all the checks man");
        }
        game.isLobbyOpen = false;

        return await this.saveMatch(game);
    }

    async getOpenLobbies() {
        return await this.matchRepo.find({
            where: {
                isLobbyOpen: true,
                status: 'pending'
            },
            relations: ['player1', 'player2', 'lobbyParticipants']
        })
    }

    async getUserActiveGames(userId: number) {
        return await this.matchRepo.createQueryBuilder("game")
            .leftJoinAndSelect("game.player1", "player1")
            .leftJoinAndSelect("game.player2", "player2")
            .leftJoinAndSelect("game.lobbyParticipants", "participants")
            .where("(player1.id = :userId OR player2.id = :userId)", { userId })
            .andWhere("gameStatus IN (:...statuses)", { statuses: ['pending', 'ongoing', 'paused'] })
            .getMany()
    }
}
